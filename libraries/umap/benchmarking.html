
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>Performance Comparison of Dimension Reduction Implementations &#8212; scikit-tda 0.0.2 documentation</title>
    <link rel="stylesheet" href="../../_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="UMAP API Guide" href="api.html" />
    <link rel="prev" title="How UMAP Works" href="how_umap_works.html" />
  
   

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api.html" title="UMAP API Guide"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="how_umap_works.html" title="How UMAP Works"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">scikit-tda 0.0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Libraries</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction</a> &#187;</li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <h2>Table Of Contents</h2>
  </div>
  <div class="sidebar-toc">
    
    
      <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Libraries</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../kepler-mapper/index.html">KeplerMapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../persim/index.html">Persim</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
</ul>

    
  </div>
</div>
  <h4>Previous topic</h4>
  <p class="topless"><a href="how_umap_works.html"
                        title="previous chapter">How UMAP Works</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="api.html"
                        title="next chapter">UMAP API Guide</a></p>
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="../../search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
      
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="../../index.html">Docs</a></li>
              
                <li><a href="../index.html">Libraries</a></li>
              
                <li><a href="index.html">UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction</a></li>
              
              <li>Performance Comparison of Dimension Reduction Implementations</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <div class="section" id="performance-comparison-of-dimension-reduction-implementations">
<h1>Performance Comparison of Dimension Reduction Implementations<a class="headerlink" href="#performance-comparison-of-dimension-reduction-implementations" title="Permalink to this headline">¶</a></h1>
<p>Different dimension reduction techniques can have quite different
computational complexity. Beyond the algorithm itself there is also the
question of how exactly it is implemented. These two factors can have a
significant role in how long it actually takes to run a given dimension
reduction. Furthermore the nature of the data you are trying to reduce
can also matter – mostly the involves the dimensionality of the
original data. Here we will take a brief look at the performance
characterstics of a number of dimension reduction implementations.</p>
<p>To start let’s get the basic tools we’ll need loaded up – numpy and
pandas obviously, but also tools to get and resample the data, and the
time module so we can perform some basic benchmarking.</p>
<div class="code ipython3 highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="k">import</span> <span class="n">fetch_mldata</span>
<span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="k">import</span> <span class="n">resample</span>
<span class="kn">import</span> <span class="nn">time</span>
</pre></div>
</div>
<p>Next we’ll need the actual dimension reduction implementations. For the
purposes of this explanation we’ll mostly stick with
<a class="reference external" href="http://scikit-learn.org/stable/">scikit-learn</a>, but for the sake of
comparison we’ll also include the
<a class="reference external" href="https://github.com/DmitryUlyanov/Multicore-TSNE">MulticoreTSNE</a>
implementation of t-SNE, which has significantly better performance than
the current scikit-learn t-SNE.</p>
<div class="code ipython3 highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.manifold</span> <span class="k">import</span> <span class="n">TSNE</span><span class="p">,</span> <span class="n">LocallyLinearEmbedding</span><span class="p">,</span> <span class="n">Isomap</span><span class="p">,</span> <span class="n">MDS</span><span class="p">,</span> <span class="n">SpectralEmbedding</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="k">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">MulticoreTSNE</span> <span class="k">import</span> <span class="n">MulticoreTSNE</span>
<span class="kn">from</span> <span class="nn">umap</span> <span class="k">import</span> <span class="n">UMAP</span>
</pre></div>
</div>
<p>Next we’ll need out plotting tools, and, of course, some data to work
with. For this performance comparison we’ll default to the now standard
benchmark of manifold learning: the MNIST digits dataset. We can use
scikit-learn’s <code class="docutils literal notranslate"><span class="pre">fetch_mldata</span></code> to grab it for us.</p>
<div class="code ipython3 highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
</pre></div>
</div>
<div class="code ipython3 highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="s1">&#39;notebook&#39;</span><span class="p">,</span>
        <span class="n">rc</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;figure.figsize&#39;</span><span class="p">:(</span><span class="mi">12</span><span class="p">,</span><span class="mi">10</span><span class="p">)},</span>
        <span class="n">palette</span><span class="o">=</span><span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s1">&#39;tab10&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<div class="code ipython3 highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mnist</span> <span class="o">=</span> <span class="n">fetch_mldata</span><span class="p">(</span><span class="s1">&#39;MNIST Original&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now it is time to start looking at performance. To start with let’s look
at how performance scales with increasing dataset size.</p>
<div class="section" id="performance-scaling-by-dataset-size">
<h2>Performance scaling by dataset size<a class="headerlink" href="#performance-scaling-by-dataset-size" title="Permalink to this headline">¶</a></h2>
<p>As the size of a dataset increases the runtime of a given dimension
reduction algorithm will increase at varying rates. If you ever want to
run your algorithm on larger datasets you will care not just about the
comparative runtime on a single small dataset, but how the performance
scales out as you move to larger datasets. We can similate this by
subsampling from MNIST digits (via scikit-learn’s convenient
<code class="docutils literal notranslate"><span class="pre">resample</span></code> utility) and looking at the runtime for varying sized
subsamples. Since there is some randomness involved here (both in the
subsample selection, and in some of the algorithms which have stochastic
aspects) we will want to run a few examples for each dataset size. We
can easily package all of this up in a simple function that will return
a convenient pandas dataframe of dataset sizes and runtimes given an
algorithm.</p>
<div class="code ipython3 highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">data_size_scaling</span><span class="p">(</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">1600</span><span class="p">],</span> <span class="n">n_runs</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_runs</span><span class="p">):</span>
            <span class="n">subsample</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">algorithm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">subsample</span><span class="p">)</span>
            <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
            <span class="k">del</span> <span class="n">subsample</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">elapsed_time</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;dataset size&#39;</span><span class="p">,</span> <span class="s1">&#39;runtime (s)&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Now we just want to run this for each of the various dimension reduction
implementations so we can look at the results. Since we don’t know how
long these runs might take we’ll start off with a very small set of
samples, scaling up to only 1600 samples.</p>
<div class="code ipython3 highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">all_algorithms</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">PCA</span><span class="p">(),</span>
    <span class="n">UMAP</span><span class="p">(),</span>
    <span class="n">MulticoreTSNE</span><span class="p">(),</span>
    <span class="n">LocallyLinearEmbedding</span><span class="p">(),</span>
    <span class="n">SpectralEmbedding</span><span class="p">(),</span>
    <span class="n">Isomap</span><span class="p">(),</span>
    <span class="n">TSNE</span><span class="p">(),</span>
    <span class="n">MDS</span><span class="p">(),</span>
<span class="p">]</span>
<span class="n">performance_data</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">algorithm</span> <span class="ow">in</span> <span class="n">all_algorithms</span><span class="p">:</span>
    <span class="n">alg_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">algorithm</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;MulticoreTSNE&#39;</span> <span class="ow">in</span> <span class="n">alg_name</span><span class="p">:</span>
        <span class="n">alg_name</span> <span class="o">=</span> <span class="s1">&#39;MulticoreTSNE&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">alg_name</span> <span class="o">=</span> <span class="n">alg_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">performance_data</span><span class="p">[</span><span class="n">alg_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_size_scaling</span><span class="p">(</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">mnist</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">n_runs</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Now let’s plot the results so we can see what is going on. We’ll use
seaborn’s regression plot to interpolate the effective scaling.</p>
<div class="code ipython3 highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">alg_name</span><span class="p">,</span> <span class="n">perf_data</span> <span class="ow">in</span> <span class="n">performance_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">regplot</span><span class="p">(</span><span class="s1">&#39;dataset size&#39;</span><span class="p">,</span> <span class="s1">&#39;runtime (s)&#39;</span><span class="p">,</span> <span class="n">perf_data</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">alg_name</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
<img alt="../../_images/performance_14_1.png" src="../../_images/performance_14_1.png" />
<p>We can see straight away that there are some outliers here. The
scikit-learn t-SNE is clearly much slower than most of the other
algorithms. It does not have the scaling properties of MDS however; for
larger dataset sizes MDS is going to quickly become completely
unmanageable. At the same time MulticoreTSNE demonstrates that t-SNE can
run fairly efficiently. It is hard to tell much about the other
implementations other than the fact that PCA is far and away the fastest
option. To see more we’ll have to look at runtimes on larger dataset
sizes. Both MDS and scikit-learn’s t-SNE are going to take too long to
run so let’s restrict ourselves to the fastest performing
implementations and see what happens as we extend out to larger dataset
sizes.</p>
<div class="code ipython3 highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fast_algorithms</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">PCA</span><span class="p">(),</span>
    <span class="n">UMAP</span><span class="p">(),</span>
    <span class="n">MulticoreTSNE</span><span class="p">(),</span>
    <span class="n">LocallyLinearEmbedding</span><span class="p">(),</span>
    <span class="n">SpectralEmbedding</span><span class="p">(),</span>
    <span class="n">Isomap</span><span class="p">(),</span>
<span class="p">]</span>
<span class="n">fast_performance_data</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">algorithm</span> <span class="ow">in</span> <span class="n">fast_algorithms</span><span class="p">:</span>
    <span class="n">alg_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">algorithm</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;MulticoreTSNE&#39;</span> <span class="ow">in</span> <span class="n">alg_name</span><span class="p">:</span>
        <span class="n">alg_name</span> <span class="o">=</span> <span class="s1">&#39;MulticoreTSNE&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">alg_name</span> <span class="o">=</span> <span class="n">alg_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">fast_performance_data</span><span class="p">[</span><span class="n">alg_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_size_scaling</span><span class="p">(</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">mnist</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                   <span class="n">sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">800</span><span class="p">,</span> <span class="mi">1600</span><span class="p">,</span> <span class="mi">3200</span><span class="p">,</span> <span class="mi">6400</span><span class="p">,</span> <span class="mi">12800</span><span class="p">],</span> <span class="n">n_runs</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="code ipython3 highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">alg_name</span><span class="p">,</span> <span class="n">perf_data</span> <span class="ow">in</span> <span class="n">fast_performance_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">regplot</span><span class="p">(</span><span class="s1">&#39;dataset size&#39;</span><span class="p">,</span> <span class="s1">&#39;runtime (s)&#39;</span><span class="p">,</span> <span class="n">perf_data</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">alg_name</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
<img alt="../../_images/performance_17_1.png" src="../../_images/performance_17_1.png" />
<p>At this point we begin to see some significant differentiation among the
different implementations. In the earlier plot MulticoreTSNE looked to
be slower than some of the other algorithms, but as we scale out to
larger datasets we see that its relative scaling performance is far
superior to the scikit-learn implementations of Isomap, spectral
embedding, and locally linear embedding.</p>
<p>It is probably worth extending out further – up to the full MNIST
digits dataset. To manage to do that in any reasonable amount of time
we’ll have to restrict out attention to an even smaller subset of
implementations. We will pare things down to just MulticoreTSNE, PCA and
UMAP.</p>
<div class="code ipython3 highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">very_fast_algorithms</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">PCA</span><span class="p">(),</span>
    <span class="n">UMAP</span><span class="p">(),</span>
    <span class="n">MulticoreTSNE</span><span class="p">(),</span>
<span class="p">]</span>
<span class="n">vfast_performance_data</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">algorithm</span> <span class="ow">in</span> <span class="n">very_fast_algorithms</span><span class="p">:</span>
    <span class="n">alg_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">algorithm</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;MulticoreTSNE&#39;</span> <span class="ow">in</span> <span class="n">alg_name</span><span class="p">:</span>
        <span class="n">alg_name</span> <span class="o">=</span> <span class="s1">&#39;MulticoreTSNE&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">alg_name</span> <span class="o">=</span> <span class="n">alg_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">vfast_performance_data</span><span class="p">[</span><span class="n">alg_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_size_scaling</span><span class="p">(</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">mnist</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                    <span class="n">sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">3200</span><span class="p">,</span> <span class="mi">6400</span><span class="p">,</span> <span class="mi">12800</span><span class="p">,</span> <span class="mi">25600</span><span class="p">,</span> <span class="mi">51200</span><span class="p">,</span> <span class="mi">70000</span><span class="p">],</span> <span class="n">n_runs</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="code ipython3 highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">alg_name</span><span class="p">,</span> <span class="n">perf_data</span> <span class="ow">in</span> <span class="n">vfast_performance_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">regplot</span><span class="p">(</span><span class="s1">&#39;dataset size&#39;</span><span class="p">,</span> <span class="s1">&#39;runtime (s)&#39;</span><span class="p">,</span> <span class="n">perf_data</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">alg_name</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
<img alt="../../_images/performance_20_1.png" src="../../_images/performance_20_1.png" />
<p>Here we see UMAP’s advantages over t-SNE really coming to the forefront.
While UMAP is clearly slower than PCA, its scaling performance is
dramatically better than MulticoreTSNE, and for even larger datasets the
difference is only going to grow.</p>
<p>This concludes our look at scaling by dataset size. The short summary is
that PCA is far and away the fastest option, but you are potentially
giving up a lot for that speed. UMAP, while not competitive with PCA, is
clearly the next best option in terms of performance among the
implementations explored here. Given the quality of results that UMAP
can provide we feel it is clearly a good option for dimension reduction.</p>
</div>
</div>


          </div>
            
  <div class="footer-relations">
    
      <div class="pull-left">
        <a class="btn btn-default" href="how_umap_works.html" title="previous chapter (use the left arrow)">How UMAP Works</a>
      </div>
    
      <div class="pull-right">
        <a class="btn btn-default" href="api.html" title="next chapter (use the right arrow)">UMAP API Guide</a>
      </div>
    </div>
    <div class="clearer"></div>
  
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api.html" title="UMAP API Guide"
             >next</a> |</li>
        <li class="right" >
          <a href="how_umap_works.html" title="How UMAP Works"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">scikit-tda 0.0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Libraries</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="../../_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 2018, Nathaniel Saul. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>